---
layout: post
title: 读高性能JavaScript笔记（2）
date: 2017-08-29
tags: [JavaScript,share]
---

今天看的高性能，在Mark一下。

## 动态作用域

昨天说到的with()语句，还有try catch中的catch语句，还有eval()的函数，都被认为是动态作用域。动态作用于只存在于代码执行当中，因此无法通过静态分析（即不通过编译执行）检测出来。例如：
	
	function execute(code){
		eval(code);
			function subroutine(){
				return window;
			}
			var w = sobroutine();
		};
	
这里就简单说一下，当涉及动态作用域的时候，浏览器的JavaScript优化引擎就会失去优化。脚本引擎将会切回较慢的基于哈希表的表示方式，这更像传统的作用域链查找，尽量别用动态作用域。

## 闭包，作用域，和内存

关于闭包的性能优化这个才有意思。

闭包是JavaScript最强大的特性，它允许函数访问局部作用域之外的数据。但是闭包是有很大的性能问题的。

	function assignEvents(){
		var id = "hahah";
		document.getElementById("div").onclick = function(e){
			saveDocument(id);
		};
	}
	assignEvents();
assignEvents()函数给一个dom元素设置事件处理函数。这个事件处理函数就是一个闭包。因为，当我们点击div的时候，事件处理函数会寻找saveDocument()函数，并且把id传进去，这就相当于，全局的函数访问到了内部的变量。

分析一下步骤，当assignEvents函数执行完毕的时候，它的执行上下文被销毁。但是，它里面的事件处理函数还保留着他原来的执行期上下文。因为，当事件处理函数定义的时候，它的执行上下文是全局对象，和局部的assingnEvents()对象，当它执行的时候，又产生出自己的执行上下文，并且保留父级函数的全部执行上下文，所以这就产生了一个闭包。

要注意的是，这个闭包是一直存在的，因为者它一直占着内存不释放。从而产生更多的内存开销，在大型的web应用中，这就可能是个问题，会导致内存泄漏。当访问点击时间越多，每次访问都会带来性能的消耗。。

因此，在脚本编程中，可以将常用的变量存储在局部变量中，从而直接访问局部变量来减轻产生闭包产生的性能消耗。

## 对象成员

这里有些要注意的地方就是，对象成员除了传统的数据类型以外，还包含函数。

当一个被命名的成员引用一个函数，该成员就被称为一个“方法”，相反，引用了非函数类型的成员就成为“属性”。

### 原型 和原型链

这个概念大家应该都很熟悉，这就不详细展开讲概念了，就讲一下注意点。

对象有两种成员类型，一种是直接存在于对象中的“实例成员”，另一种就是存在于原型链上的“原型成员”。

对象的原型决定了实力的类型。默认情况下，所有对象都是对象（object）的实例，并继承了所有的方法，（隐式调用new Object构造函，继承Object方法）。领用构造函数创建实例的时候，子函数会继承父级原型链上的所有方法。

那么问题就是，如果我们访问属性或调用方法的时候，如果子域中没有，自然就会在原型链上寻找，那么如果嵌套非常深，那么找到该方法或属性就越慢，这样就会增加性能的损失。

本来，搜索实例成员比从字面量或局部变量中读取代价更高，再加上遍历原型链带来的性能的开销，这让性能问题更为严重。

所以，如果要多次调用同一个对象的时候，我们可以对这个对象实施缓存。例如：
	
	function found(){
		var str = Object.toString();
		var a = {};
		a.object.toString();
	}

这样比直接使用object.toString 更加好。当然，这里只显示查找一次，其实这个情况是针对使用很多次的情况在使用的。嗯，今天就看了这么多，就先讲这点吧。

晚安！！





