---
layout: post
title: some difficult test
date: 2018-04-10
tags: [Interview]
---

这篇文章主要用来理解两个题目。

## 第一题

    var foo = {n: 1};
    var bar = foo;
    foo.x = foo = {n: 2};
    console.log(foo.x);
    console.log(bar.x);

首先要理解几点：

- 对于对象赋值，传递的都是引用，都是引用的调用
- 对于赋值语句，总是先对左值进行求值，然后再对右值进行求值，然后再赋值

那么对于第一二行代码，就是把一个对象({n: 2})赋给foo,然后通过foo把对象赋值给bar。这个时候，bar和foo存的都是对象{n:2}的引用。简单理解，就是如果bar把对象里面的n改了，那么foo也会跟着一起改。

接下来重点分析一下foo.x = foo = {n: 2}。按照规定对于赋值语句，总是先对lhs求值，再对rhs求值，最后在赋值。   

第一步，首先对foo.x进行求值，foo指向的是对象{n: 1}(代名词a)，a没有属性x，那么a将添加属性x，左值的求值结果就是对刚才添加的属性x的引用（某个内存地址）。

第二步，对右值进行求值，右值是foo = {n:2}。同样，相对左值求值，得到foo，foo还是a的引用，然后对右值{n: 2}求值，得到b，接着赋值，将改变foo的指向到b，赋值表达式foo={n: 2}返回得到b的引用。

第三步，赋值的时候，将左值指向b也就是第一步内存地址x存的是b的引用。

## 第二题

    (function (x, f = () => x) { //code 1
        var x ; // code 2
        var y = x;//code 3
        x = 2; // code 4
        return [x, y, f()]; // [2, 1, 1]
    })(1)

    (function (x, f = () => x) {
        var y = x; // code5
        x = 2;// code6
        return [x, y, f()]; // [2, 2, 1]
    })(1)

1.函数体内和函数体外是两个不同的命名空间或者说是作用域，函数体外的作用域是不能访问函数体内的变量的。函数的形参(x,f)和函数体{}就是两个不同的作用域。

    (function (a, f = () => x) {
        let x = 2;
        return [a, f()];
    })(1) // Uncaught ReferenceError x is not defined;

2.函数中的默认参数可用于后面的默认参数（已经遇到的参数可用于以后的默认参数）。

例如： 

    function add (a, b = a + 1, c = a + b) {
        console.log(c);
    }
    add(1);//3

在解析一下题目，

- code1: 这里首先给f函数默认赋值了一个匿名函数，这个函数可以取得参数作用域中的x，但是取不到函数体内的x。
- code2: 这里对x进行了变量声明，会分配新的地址，但是因为没有赋值，所以在作用域链还会找到形参x
- code3: 这里y的值是形参x的值
- code4: 这里对上面的声明的x进行赋值，当时形参x不受影响

第二题

- code5: 这里指声明了y，x还是形参
- code6: 这里改变了形参x的值，所以f()返回的是2

总结一下，这两道题：

1，解析是先对左值求值，之后再对右值求值

2，对于函数的形参和函数体，两者的作用域是不能共享的，默认的形参可以获取之前已经存在的形参的值。