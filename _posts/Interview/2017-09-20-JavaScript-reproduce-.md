---
layout: post
title: JavaScript 垃圾处理机制
date: 2017-09-20
tags: [Interview]
---

之前看到面试里问了一下关于JavaScript的垃圾处理，刚好最近有遇到这个东西（WeakSet，WeakMap），所以拿出来讲一讲。

# 垃圾收集

JavaScript具有自动垃圾收集机制，执行环境会负责管理代码过程中使用的内存。原理：找出那些不再继续使用的变量，然后释放其占用的内存。所以，垃圾收集器会按照固定的时间间隔（或者是代码执行中固定的收集时间），周期性的执行这一操作。

## 函数中局部变量

函数中的局部变量是有正常生命周期的。局部变量只在函数执行的过程中存在。在这个过程中，会为局部变量在栈内存上（or stack）内存上分配相应的空间，以便存储他们的值。

然后在函数中使用这些变量，直到这些函数执行结束。这个时候，局部变量就没有存在的必要了。可以释放他们的内存以供将来使用。这个时候，垃圾收集器会跟踪每个变量，判断那个变量有用，那个没有用，具体到每一个浏览器的实现，有两种方法。

## 标记清除

JavaScript中使用最多的垃圾收集方式就是标记清除（mark-and-sweep).当变量进入环境（例如，在函数中声明一个变量）是，就将这个变量即为“enter environment”。这个时候，从逻辑上看，是永远不会释放变量所占有的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开这个环境的时候，会被标记为“out of environment”。

最后，垃圾收集器，销毁带标记的值i，并回收他们所占用的空间。

## 引用计数

引用计数的含义是跟踪记录每个值被应用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，那么这个值得引用次数就是1，假设为time，那么time就是time。如果同一个值又被付给另一个变量，那么time再加1.如果，引用这个值的变量有引用其他值，那么time就减1.这样，当垃圾收集器下次再运行时，释放那些time为0的值所占用的内存。

但是这里有个问题就是，循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向A的引用。例如：

    function Problem(height,color)
        this.height = height;
        this.color = color
    }
    var myA = new Problem(1540,"green");
    var myB = new Problem(2341,"red");
    myB.color = myA.color;
    myA.height = myB.height;

这个例子中，两个对象都有各自的属性相互引用，那么就是说，它们的引用次数都是2.当函数执行完毕之后，
两个对象会继续存在，因为它们的引用次数永远不会是0.

所以很多浏览器已经使用标记清除来进行垃圾回收。

但是在IE9及以下版本中，需要手动的使用：

    some_uesnessthing = null;

这样来释放内存空间，因为旧版本IE的是引用计数形式，为了避免内存浪费，需要手动接触，等待回收器来回收（解除引用）。

## 性能问题

垃圾收集齐是周期性运行的，而且如果为变量分配的内存很大，那么回收工作量也是相当大的。这种情况下，确定垃圾回收的时间间隔是一个很重要的问题。

新版本IE中，JavaScript引擎的垃圾回收机制：触发垃圾收集的变量分配，字面量和数组元素的临界值被调整为动态修改，当垃圾收集线程会后的内存分配低于15%，那么变量，字面量和数组元素的临界值就会加倍。如果，例程挥手的内存分配量低于15%，那么各种临界值将会重置回默认值。

那么关于垃圾回收机制就讲到这把。希望大家能有所收获。

