---
layout: post
title: 前端核心知识（37）———— 网络 同源策略
date: 2017-08-11
tags: [network]
---

今天我们来讲一下关于同源策略的一些东西。

## 同源策略

浏览器有一个很重要的概念————同源策略（same-origin policy），所谓同源指的是：域名，协议，端口相同。不同源的客户端脚本（JavaScript、actionscript）在没有明确授权的情况下，不能读写对方的资源。

简单来说啊，浏览器不允许包含在腾讯页面的脚本访问阿里巴巴页面的数据资源，会受到同源策略的限制。

例如：我们在百度页面搜索：超人迪加。会有一个wd关键字，它是我们需要搜索的内容。如果搜索超人迪加，我们可以这样写：

	https://www.baidu.com/s?wd=超人迪加
	
这样就可以在百度页面搜索出超人迪加的相关信息。

但是要注意的是，这个必须是在百度页面才能访问，如果我们在本地发送请求是会报错的。

<img src="http://os310ujuc.bkt.clouddn.com/blog.png">

这就是因为同源策略的限制，我们不能在不同源的页面请求数据。（域名不相同，协议不相同）。

### URL(资源定位符)构成

协议://域名（端口号，参数，查询等）例如：

	http://www.zhidao.baidu.com

1.其中协议就是http，域名就是www.zhidao.baidu.com，域名是倒着解析的，baidu.com属于一级域名，zhidao.baidu.com属于二级域名，www是一级域名前缀，表示由万维网维护的。这个前缀是用来区别处理信息的，用来分开不同的服务器进行处理。例如邮件利用a服务器，网站用b服务器，通过前缀就可以直接找到处理网站的b服务器了。但是现在基本不需要使用www了。

zhidao.baidu.com属于百度自己进行维护的。com，org，net属于顶级域名，是在全世界范围内解析的，hk，cn，例如，cn就是在中国解析的。

2.端口、通常有几个80/90/3000等，http默认是80端口。https默认端口443.这里涉及到一个dns解析问题，

当我们输入URL之后，会进行寻找服务器，每个服务器上面有很多端口，每个端口有不同的功能，用来处理不同的业务。

## 当我们输入一个URL之后发生了什么




同源就是指协议，域名，端口都相同的网页。

1.浏览器通过DNS域名解析到服务IP（ping www.baidu.com）.

DNS解析可以将我们输入的URL解析成一个IP地址，通过这个IP地址也能直接找到该网页。

2.客户端(浏览器)通过TCP协议建立到服务器的TCP连接  (三次握手四次挥手)。

当找到服务器之后，我们需要建立一个连接才能进行数据的传输。那么通过TCP建立连接需要有一个过程，叫做“三次握手”.断开连接的时候也有一个过程叫做，“四次挥手”

3.客户端（浏览器）向web服务器端（HTTP服务器）发送HTTP协议包，请求服务器里的资源文档 （telnet 模拟）

在交互数据这里也有一个协议叫做http协议。请求服务器的资源文档。

4.服务器想客户端发送HTTP协议应答包

5.客户端和服务器断开，客户端开始解释处理HTML文档

## TCP/UDP(传输层协议)

### 面向连接的TCP

TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。


### 面向非连接的UDP协议

“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。与手机短信非常相似：你在发短信的时候，只需要输入对方手机号就OK了。
UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！

总的来说TCP协议是需要建立连接的，而UDP是不需要建立连接的。

具体过程：

第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN—SEND状态，等待服务器B确认。（先Client端发送连接请求报文。）

第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN-RECV状态。(Server段接受连接后回复ACK报文，并为这次连接分配资源。)

第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。(Client端接收到ACK报文后也向Server段发送ACK报文，并分配资源，这样TCP连接就建立了。)

完成三次握手，客户端与服务器开始传送数据

如图：
<img src="http://os310ujuc.bkt.clouddn.com/blog1.png">

四次挥手
1.Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭（Socket），可以继续发送数据。

2.server发送ACK，告诉Client端，你的请求我收到了，但是我还没准备好，请继续等我的消息。
wait:这个时候Client端就进入FIN-WAIT状态，继续等待Server端的FIN报文。

3.当Server端确定数据已发送完成，则向Client端发送FIN报文，告诉Client端，好了，我这边数据发完了，准备好关闭连接了。

4.Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME-WAIT状态，如果Server端没有收到ACK则可以重传。Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

<img src="http://os310ujuc.bkt.clouddn.com/blog3.jpg">

## 应用层协议（http和https）

超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。

HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。

上面的协议为了建立客户端与服务器端的连接，此协议为了让两者进行沟通。

为什么要有此协议呢，让计算机之间按照规矩说话，你问我答，你怎么问我怎么答，否则计算机各说各话，没办法沟通。

### http格式

http（请求报文，响应报文）通过报文进行沟通.

请求报文：

先说一下请求报文吧。首先请求报文有几部分构成：“请求头”，“请求行”，“请求主体”。

请求行：

	请求方法（GET POST DELETE HEAD TRACE OPTION）       请求资源 (URL)           请求协议版本（HTTP/1.1）

要注意的是在http1.0，每次请求的时候都需要建立连接这样很耗性能，在1.1版本，出现了一个长连接的概念，例如，如果我们有十张图片资源需要请求，这个时候，会产生一个长连接，一次就接受10张图，而不需要每张图都建立一个连接。


请求头：允许客户端传递关于自身的信息和希望的响应形式。

	Accept：指定客户端能够接收的内容类型
	Content-Length：请求的内容长度//这个就限定了post和get的数据请求长度
	Date：请求发送的日期和时间

请求主体：

	表单提交数据如：name=cst&age=18;

这个可以跟我们昨天讲的post发送数据的时候，把内容就是放在报文体里面。


<img src="http://os310ujuc.bkt.clouddn.com/%E6%8A%A5%E6%96%871.png">



关于响应报文，格式类似于请求报文，有几部分构成：“响应行”，“响应头”，“响应主体”。

响应报文：

<img src="http://os310ujuc.bkt.clouddn.com/blog5.png">

1.响应行

	响应协议版本号（HTTP/1.1）       响应状态码  （200）    响应状态文字  （0K）
	
常见的http状态码：

成功状态码：

	200 服务器成功返回内容
	301/2 临时/永久重定向
	304 资源未被修改过

失败状态码：

	404 请求内容不存在
	500 服务器暂时不可用
	503 服务器内部错误


2.响应头（HTTP Responses Header ）

	Date就是原始服务器消息发出的时间，
	Expires，响应过期的日期和时间，等

3.响应主体

          ‘sign success’ (注册成功)

响应体里面就有咱们请求回来的数据。


## 浏览器缓存机制

响应头里面有一个属性叫做ETag，它是每个数据都特有的一个唯一标识，第一次请求的时候，会把这个唯一标识缓存起来，那么在下次请求的时候会直接把这个唯一表示放到请求报文的请求头里面，再次给服务器发送的时候，有一个属性叫做“if-None-Match”它是匹配ETag的值的，如果if-None-Match和服务器的ETag一样，会返回一个304状态码，然后将本地的缓存给返回过来，如果发生改变就会返回新的资源。

### ETag交互过程

Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match.请求一个文件的流程可能如下：

	====第一次请求===
	1.客户端发起 HTTP GET 请求一个文件；
	2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如"2e681a-6-5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
	====第二次请求===
	1.客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d044840
	2.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；

还有一个if-Modified-Since是用来确定服务器发过来的资源的最后修改时间，如果发现修改了，不取缓存。

最后再讲一下一些响应头信息。

Date： 服务器响应内容日期

Cache-control：内容缓存时间

no-cache   会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。 

no-store 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。 根据缓存超时 

max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 

min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 

max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以 接收超出超时期指定值之内的响应消息。 

Expires：内容保质期，表示存在时间，允许客户端在这个时间之前不去检查（发请求），等同max-age的效果。但是如果同时存在，则被cache-control的max-age覆盖。

referer：可以统计用户从哪里点击而来的，如果从浏览器地址里直接输入地址，请求头里面是没有referer的。

好吧，那么关于同源策略和http的相关知识就讲到这，希望大家能有所收获。
