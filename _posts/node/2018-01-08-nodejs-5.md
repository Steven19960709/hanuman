---
layout: post
title: NodeJS 内存控制
date: 2018-01-08
tags: [node]
---

本来今天想讲一下关于Buffer的相关知识的，但是将buffer好像需要讲到内存控制的东西，还是现将内存的东西好了。

首先，在很久以前，JavaScript在前端操作DOM的时候，基本上是不会存在代码回收的情况，因为如果出现这种情况，网页的用户会直接刷新，，体验已经很糟糕了。随着Node出现，JavaScript有着想整个生态大统一的发展节奏，特别是Node在服务端的广泛利用，其他语言里存在着的问题，在JavaScript中也慢慢暴露出来。因此，在服务端，内存控制正是一个对资源高效利用的关键点，于是我们就需要讨论关于内存的东西了。

在JavaScript编程的时候，系统会自动进行垃圾的回收，相关的内容我之前也在博客里面讨论过，几乎很少人会遇到垃圾回收对应用程序构成性能影响的情况。但是，当Node出现，客户端延展至服务端，内存管理的好坏，垃圾回收状况是否优良，都会对服务构成影响。

## V8的内存限制

首先Node是构建在Chrome的JavaScript运行时的平台。Node在JavaScript上的执行直接受益于V8，可以虽则V8的升级就能享受到更好的性能或新的语言特性，同时也会受到一些限制。

第一个就是v8对内存的限制，Node使用内存时就会发现只能使用部分内存，64位系统大概1.4GB，32位系统大概0.7GB；这样就会导致Node无法操作大内存对象，比如，无法将一个2GB的文件读入内存中进行字符串分析处理，即使物理内存有32GB。因为V8的内存机制是针对浏览器的应用场景下的，不是服务端。为了避免出现一些开发中的问题，就需要刨根问底，更好滴管理内存。

如图：

<img src="http://outu8mec9.bkt.clouddn.com/noderom.png">

memoryUsage()方法返回3个属性，heapTotal和heapUsed是V8的堆内存使用情况，前者是以申请到的对内存，后者是当前使用的量。

当我们的代码中声明变量并赋值的时候，所使用的对象就会分配到堆中。如果申请的对空闲内存不够分配新的对象就会继续申请对内存，直到堆的大小超过V8的限制。

鉴于V8做垃圾回收的性能不高，所以对内存进行了限制，但是可以手动的对这个默认内存限制进行调整。 

    node --max-old-space-size = 1700 test.js// 单位MB
    node --max-new-space-size = 1024 test.js// 单位KB

### V8垃圾回收机制

V8的内存主要分为新生代和老生代，新生代存活时间较短，老生代较长，它们两者加起来就是V8堆的整体大小。

再分代的基础上，新生代主要采用的是Scavenge算法进行垃圾回收，而Scavenge的具体实现使用的是Cheney算法，它是一种采用复制的方式实现的垃圾回收算法，在垃圾回收的时候，通过存活对象的两个空间（From和To空间）之间进行赋值。但是缺点是只能使用对内存的一半。当一个内存被多次复制而没被释放的时候，会将它移到老生代内存中。

在老生代中的对象，采用的是Mark-Sweep（标记清除）和Mark_Compact（标记整理）相结合的方式进行垃圾回收。过程就不展开了。

## 高效的使用内存

### 作用域

相信这个大家都很熟悉，scope在垃圾回收也是很重要的。

    var foo = function () {
        var local = {};
    }

foo函数每次调用时会创建对应的作用域，执行结束，作用域将会销毁。同时作用域中声明的局部变量也将随即被销毁.

### 闭包

作用域量的对象访问只能向上，这样外部无法向内部访问。但是闭包可以实现外部作用域访问内部作用域的效果。

一般而言，函数执行玩，对应的局部变量也会被销毁随机挥手，但是如果返回值在外部函数中使用了，那么这个饮用将会一直存在。原始的作用于不会得到释放。

## 内存泄漏

在V8的垃圾回收几只下，在通常的代码编写中，很少会遇到内存写偶的问题。通常都是无意间出现的。实质都是只有一个就是应当回收的对象出现意外没有被回收，变成了常住在老生代里的对象。通常有以下几个原因：

- 缓存
- 队列消费不及时
- 作用域未释放

缓存是个好东西，它可以节省一次I/O的时间，但是缓存是生活在老生代里面的，意味这垃圾回收的时候性能不好，那么我们就不能乱用缓存了。利用内存作为缓存的行为要被限制。需要限制缓存无限增长。

    var LimitableMap = function (limit) {
        this.limit = limit || 10;
        this.map = {};
        this.keys = [];
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    limitableMap.prototype.set = function (key, value) {
        var map = this.map;
        var keys = this.keys;
        if (!hasOwnProperty.call(map, key)) {
            if (keys.length === this.limit) {
                var firstKey = keys.shift();
                delete map[firstKey];
            }
            keys.push(key);
        }
        map[key] = value;
    };
    LimitableMap.prototype.get = function (key) {
        return this.map[key];
    };
    module.exports = LimitableMap;

记录键在数组中，一旦超过数量，就以先进先出的方法进行淘汰。

关于队列带来的内存泄漏，就是当队列的消费速度低于生产速度，将会形成堆积。解决方法，最好使监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。

那么关于内存的东西就先讲到这。
































