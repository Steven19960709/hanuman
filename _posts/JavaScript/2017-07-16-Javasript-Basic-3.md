---
layout: post
date: 2017-07-16
title: 前端核心知识（12）———— JavaScript的类型转换
tags: [JavaScript]
---

大家晚上好，今天要复习一下关于JavaScript的类型转化的知识。

## 编程形式的区别 

开始正式内容之前先讲一讲，一个小话题。

编程语言按照形式上分，有两类，第一种称之为面向过程，第二种称为面向对象。

面向过程编程：主要是按照步奏来来进行编程，考虑是怎么做。典型例子为C语言。

面向对象编程：包含面向过程编程，但是它主要考虑是处理方法，利用什么资源进行编程，更加的结构化。

## typeof 运算符

在我们处理数据的时候，经常需要关注数据的类型，这时候可以使用typeof运算符。
typeof（）运算符可以区分出数据的类型，他返回六种值，分别是Object，number，string，undefined，Boolean，function。返回的是形式都是字符串形式。它还有一个特点就是，当一个变量未经声明就使用时会报错的，但是利用typeof判断一个未经声明的变量，会返回undefined，但是不报错。了解了typeof之后，我们就可以正式介绍类型转换了。

## 显式类型转换 

### Number（）

这个方法可以将传进去的参数转化为数字类型的数据，如果传进去的不能被转化为数字，就会返回NAN。

有个注意的地方就是，如果null，空串‘’，会转化成0，undefined，NAN，都会转化为NaN。

    Number('asdfa')          // NaN
    Number('12333')          // 12333
    Number(null)             // 0
    Number(undefined)        // NaN

### parseInt()

这个方法会将参数转化为数字类型，并进行数字截断处理，当传入的是数字和字符串，它会把数字单独截取。第二个用法，就是它可以进行十进制数向其他进制数进行转化。

                parseInt(123456abc)       // 123456

                parseInt("8",2)           //0100 将8 转化为2进制数。

    
第一个参数是要进行处理的数，第二个参数是填基底，就是要转化为的目标进制数。第二个参数最多是填到36进制，最小是2进制。

### parseFloat（）toFix（）

这个方法也是将参数转化为数字类型，但是它不可以进行进制的转换。

        parseFloat(252.22)         // 252.22

toFixed(),可以设定保留多少为有效数字。
    
            var a = 199.223;
            a.toFixed(2);            //199.23


### string() Boolean() 

string():这个方法就是将传进的参数转化为字符串类型的数据。

boolean():这个方法就是将传进的参数转化为true，或者是false；

### toString() 

这个方法很重要，首先它可以将调用它的变量转化字符串，第二个就是它可以将调用它的变量转化为十进制。另外可以利用它来判断object和array。这个之后可以跟大家在介绍，今天就不展开了。

## 隐式类型转化 

### isNaN（）

NaN是一个很特殊的东西，它“六亲不认”，它任何东西都等于，意思是：

              NaN === NaN 
 
 
上面的式子返回的是false，于是就有一个函数诞生，就是用来判断NaN的，这个就是isNaN（）。

它可以将传入的参数判断是否为NaN，现在给大家说一下为什么称之为隐式类型转化，这个函数究竟是怎样工作的。

首先看看这段代码：

            var num = undefined;
            var str = Number(num);   // "NaN"
            if(str === "NaN"){
            console.log(true)
            }else{
            console.log(false)
            }
    
为什么称之为隐式类型转换呢？就是因为，isNaN内部会实行一些显式的类型转换，但是我们是表面上看不到的。可以看到，isNaN函数是通过内部将传进的参数变为字符串，然后通过与字符串的NaN比较，最后达成需要的效果，这个就是它的内部运行原理。

### 其他的隐式类型转化

一元正负运算符：

            var a = "1234";
            var b = a + 1;     // 12341

可以看到，当使用+ 号进行字符串和数字类型进行操作的时候，+号两边，会有一个隐式类型转换，就是将数字调用string，然后进行拼接。

还有一个就是++运算符，请看例子：

            var a = "123";
            //Number(a) ++
            document.write(a++ + ":" + typeof(a));

最后的打印结果是："123:Number"，意思就是++，会先把a转化为数字类型（因为得出的并不是string类型），然后再进行+操作。



"< > <= >= == != " ：

        console.log(1 > false);        //true
    
当使用比较运算符的时候也会存在这种隐式类型转换，系统会将布尔值转换为数字，然后进行比较，如果是两个字符串的比较就不会发生类型转化，字符串之间的比较是阿斯克码的比较。



缺点：

因为JavaScript内部有隐式类型转换，这样，我们得到的数据就是准确度比较低这时候，我们就需要使用“===”，绝对等于，和“!==”,绝对不等于。这两个比较运算符是不会发生隐式类型转换的。



那今天就想讲到这里吧，大家晚安了。














